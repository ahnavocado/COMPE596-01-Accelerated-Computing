# This viminfo file was generated by Vim 8.1.
# You may edit it if you're careful!

# Viminfo version
|1,4

# Value of 'encoding' when this file was written
*encoding=utf-8


# hlsearch on (H) or off (h):
~h
# Last Search Pattern:
~Msle0~/\<node_single\>

# Command Line History (newest to oldest):
:wq
|2,0,1740762912,,"wq"
:q
|2,0,1740735555,,"q"
:set numbers
|2,0,1740028722,,"set numbers"
:setnumber
|2,0,1740028718,,"setnumber"
:setnum
|2,0,1740028715,,"setnum"
:set num
|2,0,1740028711,,"set num"
:q!
|2,0,1740008496,,"q!"
:set number
|2,0,1739285104,,"set number"

# Search String History (newest to oldest):
?/resi
|2,1,1740735554,47,"resi"
?/num_thread
|2,1,1739338389,47,"num_thread"
? \<node_single\>
|2,1,1739257715,,"\\<node_single\\>"

# Expression History (newest to oldest):

# Input Line History (newest to oldest):

# Debug Line History (newest to oldest):

# Registers:
"0	LINE	0
		@for N in 1  4  16  64  256  1024  4096  16384  65536  262144; do \
			echo "N = $$N"; \
|3,0,0,1,2,0,1739329087,"	@for N in 1  4  16  64  256  1024  4096  16384  65536  262144; do \\","		echo \"N = $$N\"; \\"
""1	LINE	0
	#include <stdio.h>
	#include <stdlib.h>
	#include <math.h>
	#include <omp.h>
	
	int main(int argc, char* argv[]) {
	    if (argc < 3) {
	        printf("Usage: %s <num_threads> <num_intervals>\n", argv[0]);
	        return 1;
	    }
	
	    // 사용자 입력으로 스레드 개수 및 n 설정
	    int Nthrds;
	    unsigned long long n;
	    sscanf(argv[1], "%d", &Nthrds);
	    sscanf(argv[2], "%llu", &n);
	
	    // n이 짝수가 아닌 경우 오류 처리
	    if (n % 2 != 0) {
	        printf("Error: Number of intervals (n) must be even.\n");
	        return 1;
	    }
	
	    printf("Requesting %d threads\n", Nthrds);
	    printf("Using %llu intervals\n", n);
	    
	    // OpenMP 설정
	    omp_set_dynamic(0);
	    omp_set_num_threads(Nthrds);
	
	    // 적분 구간 및 변수 설정
	    const double a = 0.0, b = M_PI / 2.0;  // M_PI를 사용하여 파이 값
	    const double h = (b - a) / n; // 구간 크기
	
	    double S = 0.0; // 최종 적분 결과
	
	    // 실행 시간 측정 시작
	    double start_time = omp_get_wtime();
	
	    // Simpson's Rule 적용 (병렬 합산)
	    #pragma omp parallel for reduction(+:S)
	    for (unsigned long long j = 1; j <= n / 2; ++j) {
	        double x0 = a + (2 * j - 2) * h;
	        double x1 = a + (2 * j - 1) * h;
	        double x2 = a + (2 * j) * h;
	        S += f(x0) + 4 * f(x1) + f(x2);
	    }
	
	    // 최종 적분 값 계산
	    S *= h / 3.0;
|3,1,1,1,50,0,1740031254,"#include <stdio.h>","#include <stdlib.h>","#include <math.h>","#include <omp.h>","","int main(int argc, char* argv[]) {","    if (argc < 3) {","        printf(\"Usage: %s <num_threads> <num_intervals>\\n\", argv[0]);","        return 1;","    }","","    // 사용자 입력으로 스레드 개수 및 n 설정","    int Nthrds;","    unsigned long long n;","    sscanf(argv[1], \"%d\", &Nthrds);","    sscanf(argv[2], \"%llu\", &n);","",>51
|<"    // n이 짝수가 아닌 경우 오류 처리","    if (n % 2 != 0) {","        printf(\"Error: Number of intervals (n) must be even.\\n\");","        return 1;","    }","","    printf(\"Requesting %d threads\\n\", Nthrds);","    printf(\"Using %llu intervals\\n\", n);","    ","    // OpenMP 설정","    omp_set_dynamic(0);","    omp_set_num_threads(Nthrds);","","    // 적분 구간 및 변수 설정","    const double a = 0.0, b = M_PI / 2.0;  // M_PI를 사용하여 파이 값",>52
|<"    const double h = (b - a) / n; // 구간 크기","","    double S = 0.0; // 최종 적분 결과","","    // 실행 시간 측정 시작","    double start_time = omp_get_wtime();","","    // Simpson's Rule 적용 (병렬 합산)","    #pragma omp parallel for reduction(+:S)","    for (unsigned long long j = 1; j <= n / 2; ++j) {","        double x0 = a + (2 * j - 2) * h;","        double x1 = a + (2 * j - 1) * h;","        double x2 = a + (2 * j) * h;",>41
|<"        S += f(x0) + 4 * f(x1) + f(x2);","    }","","    // 최종 적분 값 계산","    S *= h / 3.0;"
"2	LINE	0
	#include <stdio.h>
	#include <stdlib.h>
	#include <math.h>
	#include <omp.h>
	
	// 적분할 함수 예제: f(x) = x^2
	double f(double x) {
	    return x * x;
	}
	
	int main(int argc, char* argv[]) {
	    if (argc < 2) {
	        printf("Usage: %s <num_threads>\n", argv[0]);
	        return 1;
	    }
	
	    // 사용자 입력으로 스레드 개수 설정
	    int Nthrds;
	    sscanf(argv[1], "%d", &Nthrds);
	    printf("Requesting %d threads\n", Nthrds);
	    
	    // OpenMP 설정
	    omp_set_dynamic(0); // 동적 스레드 개수 조정 비활성화
	    omp_set_num_threads(Nthrds);
	
	    // 적분 구간 및 변수 설정
	    const unsigned long long n = 1000000000; // 10^9개의 구간
	    const double a = 0.0, b = 1.0;
	    const double h = (b - a) / n; // 구간 크기
	
	    // 배열 동적 할당
	    double* A = (double*) calloc(n + 1, sizeof(double));
	    if (A == NULL) {
	        printf("Memory allocation failed!\n");
	        return 1;
	    }
	
	    double S = 0.0; // 최종 적분 결과
	
	    // 실행 시간 측정 시작
	    double start_time = omp_get_wtime();
	
	    // 첫 번째 병렬 작업: 함수 값 평가 및 저장
	    #pragma omp parallel
	    {
	        int id = omp_get_thread_num();
	        int num_threads = omp_get_num_threads();
	        unsigned long long istart = id * (n + 1) / num_threads;
	        unsigned long long iend = (id + 1) * (n + 1) / num_threads;
	
|3,0,2,1,50,0,1740028650,"#include <stdio.h>","#include <stdlib.h>","#include <math.h>","#include <omp.h>","","// 적분할 함수 예제: f(x) = x^2","double f(double x) {","    return x * x;","}","","int main(int argc, char* argv[]) {","    if (argc < 2) {","        printf(\"Usage: %s <num_threads>\\n\", argv[0]);","        return 1;","    }","","    // 사용자 입력으로 스레드 개수 설정","    int Nthrds;","    sscanf(argv[1], \"%d\", &Nthrds);",>51
|<"    printf(\"Requesting %d threads\\n\", Nthrds);","    ","    // OpenMP 설정","    omp_set_dynamic(0); // 동적 스레드 개수 조정 비활성화","    omp_set_num_threads(Nthrds);","","    // 적분 구간 및 변수 설정","    const unsigned long long n = 1000000000; // 10^9개의 구간","    const double a = 0.0, b = 1.0;","    const double h = (b - a) / n; // 구간 크기","","    // 배열 동적 할당","    double* A = (double*) calloc(n + 1, sizeof(double));",>22
|<"    if (A == NULL) {","        printf(\"Memory allocation failed!\\n\");","        return 1;","    }","","    double S = 0.0; // 최종 적분 결과","","    // 실행 시간 측정 시작","    double start_time = omp_get_wtime();","","    // 첫 번째 병렬 작업: 함수 값 평가 및 저장","    #pragma omp parallel","    {","        int id = omp_get_thread_num();","        int num_threads = omp_get_num_threads();",>65
|<"        unsigned long long istart = id * (n + 1) / num_threads;","        unsigned long long iend = (id + 1) * (n + 1) / num_threads;",""
"3	LINE	0
	#include <stdio.h>
	#include <stdlib.h>
	#include <math.h>
	#include <omp.h>
	
	#define NTHRDS 8  // OpenMP 스레드 개수
	#define N 1000000  // 구간 개수 (짝수여야 함)
	
	// 적분할 함수 정의
	double f(double x) {
	    return acos(cos(x) / (1 + 2 * cos(x)));
	}
	
	int main() {
	    const double a = 0.0, b = M_PI_2;  // 적분 구간 [0, π/2]
	    const double h = (b - a) / N;  // 구간 길이
	    double S = 0.0;  // 최종 적분 결과 저장 변수
	
	    // NTHRDS 크기의 배열을 동적 할당하여 초기화 (segmentation fault 방지)
	    double* s = (double*)calloc(NTHRDS, sizeof(double));
	    if (s == NULL) {  
	        printf("Memory allocation failed!\n");
	        return 1;
	    }
	
	    double start_time = omp_get_wtime();  // 실행 시간 측정 시작
	
	    #pragma omp parallel
	    {
	        int id = omp_get_thread_num();  // 현재 스레드 ID 가져오기
	        if (id < NTHRDS) {  // 잘못된 접근 방지 (return 대신 if 조건)
	            int istart = id * (N / NTHRDS);
	            int iend = (id + 1) * (N / NTHRDS);
	            if (id == NTHRDS - 1) iend = N;  // 마지막 스레드는 남은 부분 포함
	
	            for (int j = istart + 1; j <= iend; ++j) {
	                if (j >= N) break;  // 범위 초과 방지
	                s[id] += f(a + (2 * j - 2) * h) + 4 * f(a + (2 * j - 1) * h) + f(a + (2 * j) * h);
	            }
	
	            s[id] *= h / 3.0;
	        }
	    }
	
	    // 모든 스레드의 부분 합을 합산
	    for (int i = 0; i < NTHRDS; i++) {
	        S += s[i];
	    }
	
	    double end_time = omp_get_wtime();  // 실행 시간 측정 끝
|3,0,3,1,50,0,1740028403,"#include <stdio.h>","#include <stdlib.h>","#include <math.h>","#include <omp.h>","","#define NTHRDS 8  // OpenMP 스레드 개수","#define N 1000000  // 구간 개수 (짝수여야 함)","","// 적분할 함수 정의","double f(double x) {","    return acos(cos(x) / (1 + 2 * cos(x)));","}","","int main() {","    const double a = 0.0, b = M_PI_2;  // 적분 구간 [0, π/2]","    const double h = (b - a) / N;  // 구간 길이",>60
|<"    double S = 0.0;  // 최종 적분 결과 저장 변수","","    // NTHRDS 크기의 배열을 동적 할당하여 초기화 (segmentation fault 방지)","    double* s = (double*)calloc(NTHRDS, sizeof(double));","    if (s == NULL) {  ","        printf(\"Memory allocation failed!\\n\");","        return 1;","    }","","    double start_time = omp_get_wtime();  // 실행 시간 측정 시작","","    #pragma omp parallel","    {",>77
|<"        int id = omp_get_thread_num();  // 현재 스레드 ID 가져오기","        if (id < NTHRDS) {  // 잘못된 접근 방지 (return 대신 if 조건)","            int istart = id * (N / NTHRDS);","            int iend = (id + 1) * (N / NTHRDS);","            if (id == NTHRDS - 1) iend = N;  // 마지막 스레드는 남은 부분 포함","","            for (int j = istart + 1; j <= iend; ++j) {","                if (j >= N) break;  // 범위 초과 방지",>100
|<"                s[id] += f(a + (2 * j - 2) * h) + 4 * f(a + (2 * j - 1) * h) + f(a + (2 * j) * h);","            }","","            s[id] *= h / 3.0;","        }","    }","","    // 모든 스레드의 부분 합을 합산","    for (int i = 0; i < NTHRDS; i++) {","        S += s[i];","    }","","    double end_time = omp_get_wtime();  // 실행 시간 측정 끝"
"4	LINE	0
	#include <stdio.h>
	#include <stdlib.h>
	#include <math.h>
	#include <omp.h>
	
	#define NTHRDS 8  // OpenMP 스레드 개수
	#define N 1000000  // 구간 개수 (짝수여야 함)
	
	// 적분할 함수 정의
	double f(double x) {
	    return acos(cos(x) / (1 + 2 * cos(x)));
	}
	
	int main() {
	    const double a = 0.0, b = M_PI_2;  // 적분 구간 [0, π/2]
	    const double h = (b - a) / N;  // 구간 길이
	    double S = 0.0;  // 최종 적분 결과 저장 변수
	
	    // NTHRDS 크기의 배열을 동적 할당하여 초기화 (segmentation fault 방지)
	    double* s = (double*)calloc(NTHRDS, sizeof(double));
	    if (s == NULL) {  
	        printf("Memory allocation failed!\n");
	        return 1;
	    }
	
	    double start_time = omp_get_wtime();  // 실행 시간 측정 시작
	
	    #pragma omp parallel
	    {
	        int id = omp_get_thread_num();  // 현재 스레드 ID 가져오기
	        if (id >= NTHRDS) return;  // 잘못된 접근 방지
	
	        int istart = id * (N / NTHRDS);
	        int iend = (id + 1) * (N / NTHRDS);
	        if (id == NTHRDS - 1) iend = N;  // 마지막 스레드는 남은 부분 포함
	
	        for (int j = istart + 1; j <= iend; ++j) {
	            if (j >= N) break;  // 범위 초과 방지
	            s[id] += f(a + (2 * j - 2) * h) + 4 * f(a + (2 * j - 1) * h) + f(a + (2 * j) * h);
	        }
	
	        s[id] *= h / 3.0;
	    }
	
	    // 모든 스레드의 부분 합을 합산
	    for (int i = 0; i < NTHRDS; i++) {
	        S += s[i];
	    }
	
	    double end_time = omp_get_wtime();  // 실행 시간 측정 끝
|3,0,4,1,50,0,1740028322,"#include <stdio.h>","#include <stdlib.h>","#include <math.h>","#include <omp.h>","","#define NTHRDS 8  // OpenMP 스레드 개수","#define N 1000000  // 구간 개수 (짝수여야 함)","","// 적분할 함수 정의","double f(double x) {","    return acos(cos(x) / (1 + 2 * cos(x)));","}","","int main() {","    const double a = 0.0, b = M_PI_2;  // 적분 구간 [0, π/2]","    const double h = (b - a) / N;  // 구간 길이",>60
|<"    double S = 0.0;  // 최종 적분 결과 저장 변수","","    // NTHRDS 크기의 배열을 동적 할당하여 초기화 (segmentation fault 방지)","    double* s = (double*)calloc(NTHRDS, sizeof(double));","    if (s == NULL) {  ","        printf(\"Memory allocation failed!\\n\");","        return 1;","    }","","    double start_time = omp_get_wtime();  // 실행 시간 측정 시작","","    #pragma omp parallel","    {",>77
|<"        int id = omp_get_thread_num();  // 현재 스레드 ID 가져오기","        if (id >= NTHRDS) return;  // 잘못된 접근 방지","","        int istart = id * (N / NTHRDS);","        int iend = (id + 1) * (N / NTHRDS);","        if (id == NTHRDS - 1) iend = N;  // 마지막 스레드는 남은 부분 포함","","        for (int j = istart + 1; j <= iend; ++j) {","            if (j >= N) break;  // 범위 초과 방지",>96
|<"            s[id] += f(a + (2 * j - 2) * h) + 4 * f(a + (2 * j - 1) * h) + f(a + (2 * j) * h);","        }","","        s[id] *= h / 3.0;","    }","","    // 모든 스레드의 부분 합을 합산","    for (int i = 0; i < NTHRDS; i++) {","        S += s[i];","    }","","    double end_time = omp_get_wtime();  // 실행 시간 측정 끝"
"5	LINE	0
	#include <stdio.h>
	#include <stdlib.h>
	#include <math.h>
	#include <omp.h>
	
	#define NTHRDS 8  // OpenMP 스레드 개수
	#define N 1000000  // 구간 개수 (짝수여야 함)
	
	// 적분할 함수 정의
	double f(double x) {
	    return acos(cos(x) / (1 + 2 * cos(x)));
	}
	
	int main() {
	    const double a = 0.0, b = M_PI_2;  // 적분 구간 [0, π/2]
	    const double h = (b - a) / N;  // 구간 길이
	    double S = 0.0;  // 최종 적분 결과 저장 변수
	    double* s = (double*)calloc(NTHRDS, sizeof(double));  // 각 스레드의 부분 합 저장
	
	    double start_time = omp_get_wtime();  // 실행 시간 측정 시작
	
	    #pragma omp parallel
	    {
	        int id = omp_get_thread_num();  // 현재 스레드 ID 가져오기
	        int istart = id * (N / NTHRDS);
	        int iend = (id + 1) * (N / NTHRDS);
	        if (id == NTHRDS - 1) iend = N;  // 마지막 스레드는 남은 부분 포함
	
	        for (int j = istart + 1; j <= iend; ++j) {
	            s[id] += f(a + (2 * j - 2) * h) + 4 * f(a + (2 * j - 1) * h) + f(a + (2 * j) * h);
	        }
	
	        s[id] *= h / 3.0;
	    }
	
	    // 모든 스레드의 부분 합을 합산
	    for (int i = 0; i < NTHRDS; i++) {
	        S += s[i];
	    }
	
	    double end_time = omp_get_wtime();  // 실행 시간 측정 끝
	
	    // 정확한 해 계산 (5π² / 24)
	    double exact_solution = (5.0 * M_PI * M_PI) / 24.0;
	    double absolute_error = fabs(S - exact_solution);
	
	    // 결과 출력
	    printf("Approximated Integral: %.15f\n", S);
	    printf("Exact Solution: %.15f\n", exact_solution);
	    printf("Absolute Error: %.15e\n", absolute_error);
|3,0,5,1,50,0,1740028100,"#include <stdio.h>","#include <stdlib.h>","#include <math.h>","#include <omp.h>","","#define NTHRDS 8  // OpenMP 스레드 개수","#define N 1000000  // 구간 개수 (짝수여야 함)","","// 적분할 함수 정의","double f(double x) {","    return acos(cos(x) / (1 + 2 * cos(x)));","}","","int main() {","    const double a = 0.0, b = M_PI_2;  // 적분 구간 [0, π/2]","    const double h = (b - a) / N;  // 구간 길이",>60
|<"    double S = 0.0;  // 최종 적분 결과 저장 변수","    double* s = (double*)calloc(NTHRDS, sizeof(double));  // 각 스레드의 부분 합 저장","","    double start_time = omp_get_wtime();  // 실행 시간 측정 시작","","    #pragma omp parallel","    {","        int id = omp_get_thread_num();  // 현재 스레드 ID 가져오기","        int istart = id * (N / NTHRDS);","        int iend = (id + 1) * (N / NTHRDS);",>89
|<"        if (id == NTHRDS - 1) iend = N;  // 마지막 스레드는 남은 부분 포함","","        for (int j = istart + 1; j <= iend; ++j) {","            s[id] += f(a + (2 * j - 2) * h) + 4 * f(a + (2 * j - 1) * h) + f(a + (2 * j) * h);","        }","","        s[id] *= h / 3.0;","    }","","    // 모든 스레드의 부분 합을 합산","    for (int i = 0; i < NTHRDS; i++) {","        S += s[i];","    }","","    double end_time = omp_get_wtime();  // 실행 시간 측정 끝",>2
|<"","    // 정확한 해 계산 (5π² / 24)","    double exact_solution = (5.0 * M_PI * M_PI) / 24.0;","    double absolute_error = fabs(S - exact_solution);","","    // 결과 출력","    printf(\"Approximated Integral: %.15f\\n\", S);","    printf(\"Exact Solution: %.15f\\n\", exact_solution);","    printf(\"Absolute Error: %.15e\\n\", absolute_error);"
"6	LINE	0
	#include <stdio.h>
	#include <stdlib.h>
	#include <math.h>
	#include <omp.h>
	
	#define NTHRDS 8  // OpenMP 스레드 개수
	#define N 100000  // 구간 개수 (짝수여야 함)
	
	// 적분할 함수 정의
	double f(double x) {
	    return acos(cos(x) / (1 + 2 * cos(x)));
	}
	
	int main() {
	    const double a = 0.0, b = M_PI_2;  // 적분 구간 [0, π/2]
	    const double h = (b - a) / N;  // 구간 길이
	    double S = 0.0;  // 최종 적분 결과 저장 변수
	    double* s = (double*)calloc(NTHRDS, sizeof(double));  // 각 스레드의 부분 합 저장
	
	    double start_time = omp_get_wtime();  // 실행 시간 측정 시작
	
	    #pragma omp parallel
	    {
	        int id = omp_get_thread_num();  // 현재 스레드 ID 가져오기
	        int istart = id * (N / NTHRDS);
	        int iend = (id + 1) * (N / NTHRDS);
	        if (id == NTHRDS - 1) iend = N;  // 마지막 스레드는 남은 부분 포함
	
	        for (int j = istart + 1; j <= iend; ++j) {
	            s[id] += f(a + (2 * j - 2) * h) + 4 * f(a + (2 * j - 1) * h) + f(a + (2 * j) * h);
	        }
	
	        s[id] *= h / 3.0;
	    }
	
	    // 모든 스레드의 부분 합을 합산
	    for (int i = 0; i < NTHRDS; i++) {
	        S += s[i];
	    }
	
	    double end_time = omp_get_wtime();  // 실행 시간 측정 끝
	
	    // 정확한 해 계산 (5π² / 24)
	    double exact_solution = (5.0 * M_PI * M_PI) / 24.0;
	    double absolute_error = fabs(S - exact_solution);
	
	    // 결과 출력
	    printf("Approximated Integral: %.15f\n", S);
	    printf("Exact Solution: %.15f\n", exact_solution);
	    printf("Absolute Error: %.15e\n", absolute_error);
|3,0,6,1,50,0,1740027990,"#include <stdio.h>","#include <stdlib.h>","#include <math.h>","#include <omp.h>","","#define NTHRDS 8  // OpenMP 스레드 개수","#define N 100000  // 구간 개수 (짝수여야 함)","","// 적분할 함수 정의","double f(double x) {","    return acos(cos(x) / (1 + 2 * cos(x)));","}","","int main() {","    const double a = 0.0, b = M_PI_2;  // 적분 구간 [0, π/2]","    const double h = (b - a) / N;  // 구간 길이",>60
|<"    double S = 0.0;  // 최종 적분 결과 저장 변수","    double* s = (double*)calloc(NTHRDS, sizeof(double));  // 각 스레드의 부분 합 저장","","    double start_time = omp_get_wtime();  // 실행 시간 측정 시작","","    #pragma omp parallel","    {","        int id = omp_get_thread_num();  // 현재 스레드 ID 가져오기","        int istart = id * (N / NTHRDS);","        int iend = (id + 1) * (N / NTHRDS);",>89
|<"        if (id == NTHRDS - 1) iend = N;  // 마지막 스레드는 남은 부분 포함","","        for (int j = istart + 1; j <= iend; ++j) {","            s[id] += f(a + (2 * j - 2) * h) + 4 * f(a + (2 * j - 1) * h) + f(a + (2 * j) * h);","        }","","        s[id] *= h / 3.0;","    }","","    // 모든 스레드의 부분 합을 합산","    for (int i = 0; i < NTHRDS; i++) {","        S += s[i];","    }","","    double end_time = omp_get_wtime();  // 실행 시간 측정 끝",>2
|<"","    // 정확한 해 계산 (5π² / 24)","    double exact_solution = (5.0 * M_PI * M_PI) / 24.0;","    double absolute_error = fabs(S - exact_solution);","","    // 결과 출력","    printf(\"Approximated Integral: %.15f\\n\", S);","    printf(\"Exact Solution: %.15f\\n\", exact_solution);","    printf(\"Absolute Error: %.15e\\n\", absolute_error);"
"7	LINE	0
	#include <stdio.h>
	#include <stdlib.h>
	#include <math.h>
	#include <omp.h>
	
	#define NTHRDS 8  // OpenMP 스레드 개수
	#define N 1000000  // 구간 개수 (짝수여야 함)
	
	// 적분할 함수 정의
	double f(double x) {
	    return acos(cos(x) / (1 + 2 * cos(x)));
	}
	
	int main() {
	    const double a = 0.0, b = M_PI_2;  // 적분 구간 [0, π/2]
	    const double h = (b - a) / N;  // 구간 길이
	    double S = 0.0;  // 최종 적분 결과 저장 변수
	    double* s = (double*)calloc(NTHRDS, sizeof(double));  // 각 스레드의 부분 합 저장
	
	    double start_time = omp_get_wtime();  // 실행 시간 측정 시작
	
	    #pragma omp parallel
	    {
	        int id = omp_get_thread_num();  // 현재 스레드 ID 가져오기
	        int istart = id * (N / NTHRDS);
	        int iend = (id + 1) * (N / NTHRDS);
	        if (id == NTHRDS - 1) iend = N;  // 마지막 스레드는 남은 부분 포함
	
	        for (int j = istart + 1; j <= iend; ++j) {
	            s[id] += f(a + (2 * j - 2) * h) + 4 * f(a + (2 * j - 1) * h) + f(a + (2 * j) * h);
	        }
	
	        s[id] *= h / 3.0;
	    }
	
	    // 모든 스레드의 부분 합을 합산
	    for (int i = 0; i < NTHRDS; i++) {
	        S += s[i];
	    }
	
	    double end_time = omp_get_wtime();  // 실행 시간 측정 끝
	
	    // 정확한 해 계산 (5π² / 24)
	    double exact_solution = (5.0 * M_PI * M_PI) / 24.0;
	    double absolute_error = fabs(S - exact_solution);
	
	    // 결과 출력
	    printf("Approximated Integral: %.15f\n", S);
	    printf("Exact Solution: %.15f\n", exact_solution);
	    printf("Absolute Error: %.15e\n", absolute_error);
|3,0,7,1,50,0,1740027055,"#include <stdio.h>","#include <stdlib.h>","#include <math.h>","#include <omp.h>","","#define NTHRDS 8  // OpenMP 스레드 개수","#define N 1000000  // 구간 개수 (짝수여야 함)","","// 적분할 함수 정의","double f(double x) {","    return acos(cos(x) / (1 + 2 * cos(x)));","}","","int main() {","    const double a = 0.0, b = M_PI_2;  // 적분 구간 [0, π/2]","    const double h = (b - a) / N;  // 구간 길이",>60
|<"    double S = 0.0;  // 최종 적분 결과 저장 변수","    double* s = (double*)calloc(NTHRDS, sizeof(double));  // 각 스레드의 부분 합 저장","","    double start_time = omp_get_wtime();  // 실행 시간 측정 시작","","    #pragma omp parallel","    {","        int id = omp_get_thread_num();  // 현재 스레드 ID 가져오기","        int istart = id * (N / NTHRDS);","        int iend = (id + 1) * (N / NTHRDS);",>89
|<"        if (id == NTHRDS - 1) iend = N;  // 마지막 스레드는 남은 부분 포함","","        for (int j = istart + 1; j <= iend; ++j) {","            s[id] += f(a + (2 * j - 2) * h) + 4 * f(a + (2 * j - 1) * h) + f(a + (2 * j) * h);","        }","","        s[id] *= h / 3.0;","    }","","    // 모든 스레드의 부분 합을 합산","    for (int i = 0; i < NTHRDS; i++) {","        S += s[i];","    }","","    double end_time = omp_get_wtime();  // 실행 시간 측정 끝",>2
|<"","    // 정확한 해 계산 (5π² / 24)","    double exact_solution = (5.0 * M_PI * M_PI) / 24.0;","    double absolute_error = fabs(S - exact_solution);","","    // 결과 출력","    printf(\"Approximated Integral: %.15f\\n\", S);","    printf(\"Exact Solution: %.15f\\n\", exact_solution);","    printf(\"Absolute Error: %.15e\\n\", absolute_error);"
"8	LINE	0
	#include <stdio.h>
	#include <stdlib.h>
	#include <math.h>
	#include <omp.h>
	
	#define NTHRDS 8  // OpenMP 스레드 개수
	#define N 1000000  // 구간 개수 (짝수여야 함)
	
	// 적분할 함수 정의
	double f(double x) {
	    return acos(cos(x) / (1 + 2 * cos(x)));
	}
	
	int main() {
	    const double a = 0.0, b = M_PI_2;  // 적분 구간 [0, π/2]
	    const double h = (b - a) / N;  // 구간 길이
	    double S = 0.0;  // 최종 적분 결과 저장 변수
	    double* s = (double*)calloc(NTHRDS, sizeof(double));  // 각 스레드의 부분 합 저장
	
	    double start_time = omp_get_wtime();  // 실행 시간 측정 시작
	
	    #pragma omp parallel
	    {
	        int id = omp_get_thread_num();  // 현재 스레드 ID 가져오기
	        int istart = id * (N / NTHRDS);
	        int iend = (id + 1) * (N / NTHRDS);
	        if (id == NTHRDS - 1) iend = N;  // 마지막 스레드는 남은 부분 포함
	
	        for (int j = istart + 1; j <= iend; ++j) {
	            s[id] += f(a + (2 * j - 2) * h) + 4 * f(a + (2 * j - 1) * h) + f(a + (2 * j) * h);
	        }
	
	        s[id] *= h / 3.0;
	    }
	
	    // 모든 스레드의 부분 합을 합산
	    for (int i = 0; i < NTHRDS; i++) {
	        S += s[i];
	    }
	
	    double end_time = omp_get_wtime();  // 실행 시간 측정 끝
	
	    // 정확한 해 계산 (5π² / 24)
	    double exact_solution = (5.0 * M_PI * M_PI) / 24.0;
	    double absolute_error = fabs(S - exact_solution);
	
	    // 결과 출력
	    printf("Approximated Integral: %.15f\n", S);
	    printf("Exact Solution: %.15f\n", exact_solution);
	    printf("Absolute Error: %.15e\n", absolute_error);
|3,0,8,1,50,0,1740008509,"#include <stdio.h>","#include <stdlib.h>","#include <math.h>","#include <omp.h>","","#define NTHRDS 8  // OpenMP 스레드 개수","#define N 1000000  // 구간 개수 (짝수여야 함)","","// 적분할 함수 정의","double f(double x) {","    return acos(cos(x) / (1 + 2 * cos(x)));","}","","int main() {","    const double a = 0.0, b = M_PI_2;  // 적분 구간 [0, π/2]","    const double h = (b - a) / N;  // 구간 길이",>60
|<"    double S = 0.0;  // 최종 적분 결과 저장 변수","    double* s = (double*)calloc(NTHRDS, sizeof(double));  // 각 스레드의 부분 합 저장","","    double start_time = omp_get_wtime();  // 실행 시간 측정 시작","","    #pragma omp parallel","    {","        int id = omp_get_thread_num();  // 현재 스레드 ID 가져오기","        int istart = id * (N / NTHRDS);","        int iend = (id + 1) * (N / NTHRDS);",>89
|<"        if (id == NTHRDS - 1) iend = N;  // 마지막 스레드는 남은 부분 포함","","        for (int j = istart + 1; j <= iend; ++j) {","            s[id] += f(a + (2 * j - 2) * h) + 4 * f(a + (2 * j - 1) * h) + f(a + (2 * j) * h);","        }","","        s[id] *= h / 3.0;","    }","","    // 모든 스레드의 부분 합을 합산","    for (int i = 0; i < NTHRDS; i++) {","        S += s[i];","    }","","    double end_time = omp_get_wtime();  // 실행 시간 측정 끝",>2
|<"","    // 정확한 해 계산 (5π² / 24)","    double exact_solution = (5.0 * M_PI * M_PI) / 24.0;","    double absolute_error = fabs(S - exact_solution);","","    // 결과 출력","    printf(\"Approximated Integral: %.15f\\n\", S);","    printf(\"Exact Solution: %.15f\\n\", exact_solution);","    printf(\"Absolute Error: %.15e\\n\", absolute_error);"
"9	LINE	0
	#include <stdio.h>
	#include <stdlib.h>
	#include <math.h>
	#include <omp.h>
	
	// 적분할 함수 예제: f(x) = x^2
	double f(double x) {
	    return x * x;
	}
	
	int main(int argc, char* argv[]) {
	    if (argc < 2) {
	        printf("Usage: %s <num_threads>\n", argv[0]);
	        return 1;
	    }
	
	    // 사용자 입력으로 스레드 개수 설정
	    int Nthrds;
	    sscanf(argv[1], "%d", &Nthrds);
	    printf("Requesting %d threads\n", Nthrds);
	    
	    // OpenMP 설정
	    omp_set_dynamic(0); // 동적 스레드 개수 조정 비활성화
	    omp_set_num_threads(Nthrds);
	
	    // 적분 구간 및 변수 설정
	    const unsigned long long n = 1000000000; // 10^9개의 구간
	    const double a = 0.0, b = 1.0;
	    const double h = (b - a) / n; // 구간 크기
	
	    // 배열 동적 할당
	    double* A = (double*) calloc(n + 1, sizeof(double));
	    if (A == NULL) {
	        printf("Memory allocation failed!\n");
	        return 1;
	    }
	
	    double S = 0.0; // 최종 적분 결과
	
	    // 실행 시간 측정 시작
	    double start_time = omp_get_wtime();
	
	    // 첫 번째 병렬 작업: 함수 값 평가 및 저장
	    #pragma omp parallel
	    {
	        int id = omp_get_thread_num();
	        int num_threads = omp_get_num_threads();
	        unsigned long long istart = id * (n + 1) / num_threads;
	        unsigned long long iend = (id + 1) * (n + 1) / num_threads;
	
|3,0,9,1,50,0,1740008501,"#include <stdio.h>","#include <stdlib.h>","#include <math.h>","#include <omp.h>","","// 적분할 함수 예제: f(x) = x^2","double f(double x) {","    return x * x;","}","","int main(int argc, char* argv[]) {","    if (argc < 2) {","        printf(\"Usage: %s <num_threads>\\n\", argv[0]);","        return 1;","    }","","    // 사용자 입력으로 스레드 개수 설정","    int Nthrds;","    sscanf(argv[1], \"%d\", &Nthrds);",>51
|<"    printf(\"Requesting %d threads\\n\", Nthrds);","    ","    // OpenMP 설정","    omp_set_dynamic(0); // 동적 스레드 개수 조정 비활성화","    omp_set_num_threads(Nthrds);","","    // 적분 구간 및 변수 설정","    const unsigned long long n = 1000000000; // 10^9개의 구간","    const double a = 0.0, b = 1.0;","    const double h = (b - a) / n; // 구간 크기","","    // 배열 동적 할당","    double* A = (double*) calloc(n + 1, sizeof(double));",>22
|<"    if (A == NULL) {","        printf(\"Memory allocation failed!\\n\");","        return 1;","    }","","    double S = 0.0; // 최종 적분 결과","","    // 실행 시간 측정 시작","    double start_time = omp_get_wtime();","","    // 첫 번째 병렬 작업: 함수 값 평가 및 저장","    #pragma omp parallel","    {","        int id = omp_get_thread_num();","        int num_threads = omp_get_num_threads();",>65
|<"        unsigned long long istart = id * (n + 1) / num_threads;","        unsigned long long iend = (id + 1) * (n + 1) / num_threads;",""

# File marks:
'0  50  2  ~/workspace/P04/0_serial.c
|4,48,50,2,1740762912,"~/workspace/P04/0_serial.c"
'1  77  0  ~/workspace/P04/7_parallel.c
|4,49,77,0,1740762670,"~/workspace/P04/7_parallel.c"
'2  50  4  ~/workspace/P04/0_serial.c
|4,50,50,4,1740760809,"~/workspace/P04/0_serial.c"
'3  37  0  ~/workspace/P04/test.sh
|4,51,37,0,1740738507,"~/workspace/P04/test.sh"
'4  79  0  ~/workspace/P04/4_parallel.c
|4,52,79,0,1740737847,"~/workspace/P04/4_parallel.c"
'5  73  0  ~/workspace/P04/5_gpu.c
|4,53,73,0,1740737510,"~/workspace/P04/5_gpu.c"
'6  72  0  ~/workspace/P04/4_extra.c
|4,54,72,0,1740736746,"~/workspace/P04/4_extra.c"
'7  50  3  ~/workspace/P04/0_serial.c
|4,55,50,3,1740735662,"~/workspace/P04/0_serial.c"
'8  50  3  ~/workspace/P04/0_serial.c
|4,56,50,3,1740735662,"~/workspace/P04/0_serial.c"
'9  47  0  ~/workspace/P04/1_parallel.c
|4,57,47,0,1740735555,"~/workspace/P04/1_parallel.c"

# Jumplist (newest first):
-'  50  2  ~/workspace/P04/0_serial.c
|4,39,50,2,1740762912,"~/workspace/P04/0_serial.c"
-'  77  0  ~/workspace/P04/7_parallel.c
|4,39,77,0,1740762670,"~/workspace/P04/7_parallel.c"
-'  77  0  ~/workspace/P04/7_parallel.c
|4,39,77,0,1740762670,"~/workspace/P04/7_parallel.c"
-'  1  0  ~/workspace/P04/7_parallel.c
|4,39,1,0,1740762666,"~/workspace/P04/7_parallel.c"
-'  1  0  ~/workspace/P04/7_parallel.c
|4,39,1,0,1740762666,"~/workspace/P04/7_parallel.c"
-'  50  4  ~/workspace/P04/0_serial.c
|4,39,50,4,1740760809,"~/workspace/P04/0_serial.c"
-'  50  4  ~/workspace/P04/0_serial.c
|4,39,50,4,1740760809,"~/workspace/P04/0_serial.c"
-'  37  0  ~/workspace/P04/test.sh
|4,39,37,0,1740738507,"~/workspace/P04/test.sh"
-'  37  0  ~/workspace/P04/test.sh
|4,39,37,0,1740738507,"~/workspace/P04/test.sh"
-'  37  0  ~/workspace/P04/test.sh
|4,39,37,0,1740738507,"~/workspace/P04/test.sh"
-'  37  0  ~/workspace/P04/test.sh
|4,39,37,0,1740738507,"~/workspace/P04/test.sh"
-'  37  0  ~/workspace/P04/test.sh
|4,39,37,0,1740738507,"~/workspace/P04/test.sh"
-'  37  0  ~/workspace/P04/test.sh
|4,39,37,0,1740738507,"~/workspace/P04/test.sh"
-'  37  0  ~/workspace/P04/test.sh
|4,39,37,0,1740738507,"~/workspace/P04/test.sh"
-'  37  0  ~/workspace/P04/test.sh
|4,39,37,0,1740738507,"~/workspace/P04/test.sh"
-'  1  0  ~/workspace/P04/test.sh
|4,39,1,0,1740738504,"~/workspace/P04/test.sh"
-'  1  0  ~/workspace/P04/test.sh
|4,39,1,0,1740738504,"~/workspace/P04/test.sh"
-'  1  0  ~/workspace/P04/test.sh
|4,39,1,0,1740738504,"~/workspace/P04/test.sh"
-'  1  0  ~/workspace/P04/test.sh
|4,39,1,0,1740738504,"~/workspace/P04/test.sh"
-'  1  0  ~/workspace/P04/test.sh
|4,39,1,0,1740738504,"~/workspace/P04/test.sh"
-'  1  0  ~/workspace/P04/test.sh
|4,39,1,0,1740738504,"~/workspace/P04/test.sh"
-'  1  0  ~/workspace/P04/test.sh
|4,39,1,0,1740738504,"~/workspace/P04/test.sh"
-'  1  0  ~/workspace/P04/test.sh
|4,39,1,0,1740738504,"~/workspace/P04/test.sh"
-'  79  0  ~/workspace/P04/4_parallel.c
|4,39,79,0,1740737847,"~/workspace/P04/4_parallel.c"
-'  79  0  ~/workspace/P04/4_parallel.c
|4,39,79,0,1740737847,"~/workspace/P04/4_parallel.c"
-'  79  0  ~/workspace/P04/4_parallel.c
|4,39,79,0,1740737847,"~/workspace/P04/4_parallel.c"
-'  79  0  ~/workspace/P04/4_parallel.c
|4,39,79,0,1740737847,"~/workspace/P04/4_parallel.c"
-'  79  0  ~/workspace/P04/4_parallel.c
|4,39,79,0,1740737847,"~/workspace/P04/4_parallel.c"
-'  79  0  ~/workspace/P04/4_parallel.c
|4,39,79,0,1740737847,"~/workspace/P04/4_parallel.c"
-'  79  0  ~/workspace/P04/4_parallel.c
|4,39,79,0,1740737847,"~/workspace/P04/4_parallel.c"
-'  79  0  ~/workspace/P04/4_parallel.c
|4,39,79,0,1740737847,"~/workspace/P04/4_parallel.c"
-'  79  0  ~/workspace/P04/4_parallel.c
|4,39,79,0,1740737847,"~/workspace/P04/4_parallel.c"
-'  79  0  ~/workspace/P04/4_parallel.c
|4,39,79,0,1740737847,"~/workspace/P04/4_parallel.c"
-'  79  0  ~/workspace/P04/4_parallel.c
|4,39,79,0,1740737847,"~/workspace/P04/4_parallel.c"
-'  79  0  ~/workspace/P04/4_parallel.c
|4,39,79,0,1740737847,"~/workspace/P04/4_parallel.c"
-'  79  0  ~/workspace/P04/4_parallel.c
|4,39,79,0,1740737847,"~/workspace/P04/4_parallel.c"
-'  79  0  ~/workspace/P04/4_parallel.c
|4,39,79,0,1740737847,"~/workspace/P04/4_parallel.c"
-'  79  0  ~/workspace/P04/4_parallel.c
|4,39,79,0,1740737847,"~/workspace/P04/4_parallel.c"
-'  79  0  ~/workspace/P04/4_parallel.c
|4,39,79,0,1740737847,"~/workspace/P04/4_parallel.c"
-'  1  0  ~/workspace/P04/4_parallel.c
|4,39,1,0,1740737844,"~/workspace/P04/4_parallel.c"
-'  1  0  ~/workspace/P04/4_parallel.c
|4,39,1,0,1740737844,"~/workspace/P04/4_parallel.c"
-'  1  0  ~/workspace/P04/4_parallel.c
|4,39,1,0,1740737844,"~/workspace/P04/4_parallel.c"
-'  1  0  ~/workspace/P04/4_parallel.c
|4,39,1,0,1740737844,"~/workspace/P04/4_parallel.c"
-'  1  0  ~/workspace/P04/4_parallel.c
|4,39,1,0,1740737844,"~/workspace/P04/4_parallel.c"
-'  1  0  ~/workspace/P04/4_parallel.c
|4,39,1,0,1740737844,"~/workspace/P04/4_parallel.c"
-'  1  0  ~/workspace/P04/4_parallel.c
|4,39,1,0,1740737844,"~/workspace/P04/4_parallel.c"
-'  1  0  ~/workspace/P04/4_parallel.c
|4,39,1,0,1740737844,"~/workspace/P04/4_parallel.c"
-'  1  0  ~/workspace/P04/4_parallel.c
|4,39,1,0,1740737844,"~/workspace/P04/4_parallel.c"
-'  1  0  ~/workspace/P04/4_parallel.c
|4,39,1,0,1740737844,"~/workspace/P04/4_parallel.c"
-'  1  0  ~/workspace/P04/4_parallel.c
|4,39,1,0,1740737844,"~/workspace/P04/4_parallel.c"
-'  1  0  ~/workspace/P04/4_parallel.c
|4,39,1,0,1740737844,"~/workspace/P04/4_parallel.c"
-'  1  0  ~/workspace/P04/4_parallel.c
|4,39,1,0,1740737844,"~/workspace/P04/4_parallel.c"
-'  1  0  ~/workspace/P04/4_parallel.c
|4,39,1,0,1740737844,"~/workspace/P04/4_parallel.c"
-'  1  0  ~/workspace/P04/4_parallel.c
|4,39,1,0,1740737844,"~/workspace/P04/4_parallel.c"
-'  1  0  ~/workspace/P04/4_parallel.c
|4,39,1,0,1740737844,"~/workspace/P04/4_parallel.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  73  0  ~/workspace/P04/5_gpu.c
|4,39,73,0,1740737510,"~/workspace/P04/5_gpu.c"
-'  1  0  ~/workspace/P04/5_gpu.c
|4,39,1,0,1740737504,"~/workspace/P04/5_gpu.c"
-'  1  0  ~/workspace/P04/5_gpu.c
|4,39,1,0,1740737504,"~/workspace/P04/5_gpu.c"
-'  1  0  ~/workspace/P04/5_gpu.c
|4,39,1,0,1740737504,"~/workspace/P04/5_gpu.c"
-'  1  0  ~/workspace/P04/5_gpu.c
|4,39,1,0,1740737504,"~/workspace/P04/5_gpu.c"
-'  1  0  ~/workspace/P04/5_gpu.c
|4,39,1,0,1740737504,"~/workspace/P04/5_gpu.c"
-'  1  0  ~/workspace/P04/5_gpu.c
|4,39,1,0,1740737504,"~/workspace/P04/5_gpu.c"
-'  1  0  ~/workspace/P04/5_gpu.c
|4,39,1,0,1740737504,"~/workspace/P04/5_gpu.c"
-'  1  0  ~/workspace/P04/5_gpu.c
|4,39,1,0,1740737504,"~/workspace/P04/5_gpu.c"
-'  1  0  ~/workspace/P04/5_gpu.c
|4,39,1,0,1740737504,"~/workspace/P04/5_gpu.c"
-'  1  0  ~/workspace/P04/5_gpu.c
|4,39,1,0,1740737504,"~/workspace/P04/5_gpu.c"
-'  1  0  ~/workspace/P04/5_gpu.c
|4,39,1,0,1740737504,"~/workspace/P04/5_gpu.c"
-'  1  0  ~/workspace/P04/5_gpu.c
|4,39,1,0,1740737504,"~/workspace/P04/5_gpu.c"
-'  1  0  ~/workspace/P04/5_gpu.c
|4,39,1,0,1740737504,"~/workspace/P04/5_gpu.c"

# History of marks within files (newest to oldest):

> ~/workspace/P04/0_serial.c
	*	1740762911	0
	"	50	2
	^	50	3
	.	50	3
	+	80	1
	+	50	3

> ~/workspace/P04/7_parallel.c
	*	1740762669	0
	"	77	0
	^	77	0
	.	76	1
	+	76	1

> ~/workspace/P04/test.sh
	*	1740738506	0
	"	37	0
	^	37	0
	.	36	40
	+	36	40

> ~/workspace/P04/4_parallel.c
	*	1740737845	0
	"	79	0
	^	79	0
	.	78	1
	+	78	1

> ~/workspace/P04/5_gpu.c
	*	1740737509	0
	"	73	0
	^	73	0
	.	73	0
	+	73	0

> ~/workspace/P04/4_extra.c
	*	1740736745	0
	"	72	0
	^	72	1
	.	72	0
	+	72	0

> ~/workspace/P04/1_parallel.c
	*	1740735554	0
	"	47	0
	^	76	0
	.	75	1
	+	75	1

> ~/workspace/P04/a.txt
	*	1740720696	0
	"	1	0

> ~/workspace/P04/3_simd.c
	*	1740719355	0
	"	70	0
	^	70	0
	.	69	1
	+	69	1

> ~/workspace/P04/2_gpu.c
	*	1740719339	0
	"	69	0
	^	69	1
	.	70	0
	+	70	0

> ~/workspace/P03/orign_2.c
	*	1740031256	0
	"	72	0
	^	72	0
	.	72	0
	+	1	18
	+	72	0

> ~/workspace/P03/orign_1.c
	*	1740029018	0
	"	74	0
	^	74	0
	.	73	1
	+	73	1

> ~/workspace/P03/orign_0.c
	*	1740028731	0
	"	29	36
	^	29	37
	.	29	36
	+	1	18
	+	1	1
	+	1	18
	+	65	0
	+	29	36

> ~/workspace/P03/imp_0.c
	*	1740007210	0
	"	42	15
	^	42	16
	.	42	16
	+	1	0
	+	1	16
	+	1	18
	+	1	0
	+	1	18
	+	54	0
	+	34	0
	+	42	15
	+	6	20
	+	42	16

> ~/workspace/P02/Node_single.c
	*	1739344284	0
	"	71	0
	^	71	0
	.	70	1
	+	1	1
	+	1	17
	+	1	1
	+	1	5
	+	1	54
	+	1	4
	+	1	0
	+	1	4
	+	1	26
	+	1	13
	+	70	1

> ~/workspace/P02/Makefile
	*	1739339090	0
	"	37	39
	^	37	40
	.	37	39
	+	1	6
	+	1	3
	+	1	6
	+	1	23
	+	1	0
	+	1	4
	+	1	29
	+	1	5
	+	1	11
	+	1	5
	+	1	55
	+	1	0
	+	1	13
	+	1	4
	+	1	28
	+	1	48
	+	1	11
	+	1	37
	+	1	8
	+	1	0
	+	1	20
	+	1	56
	+	1	77
	+	1	57
	+	1	58
	+	1	59
	+	1	0
	+	1	13
	+	1	5
	+	1	36
	+	1	8
	+	44	38
	+	37	39

> ~/workspace/P02/Node.c
	*	1739338791	0
	"	104	0
	^	104	0
	.	103	1
	+	1	17
	+	1	0
	+	1	5
	+	1	14
	+	1	4
	+	1	16
	+	1	4
	+	1	0
	+	1	34
	+	1	4
	+	1	27
	+	1	25
	+	1	18
	+	1	17
	+	103	1

> ~/workspace/P02/node_single.c
	*	1739336561	0
	"	1	0

> ~/workspace/P02/Node_auto.c
	*	1739336226	0
	"	90	0
	^	90	0
	.	89	1
	+	89	1

> ~/workspace/P02/Node.h
	*	1739257526	0
	"	21	0
	^	21	0
	.	20	16
	+	20	16

> ~/workspace/P01/final.c
	*	1738520593	0
	"	69	0
	^	69	1
	.	69	0
	+	1	16
	+	69	0

> ~/workspace/P01/test_0.c
	*	1738402640	0
	"	36	48
	^	36	49
	.	36	48
	+	1	16
	+	66	1
	+	36	48

> ~/workspace/P01/test_0
	*	1738282252	0
	"	1	0

> ~/workspace/250124/hi.c
	*	1737997520	0
	"	15	0
	^	15	0
	.	14	0
	+	14	0
